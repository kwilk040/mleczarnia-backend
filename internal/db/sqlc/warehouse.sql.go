// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: warehouse.sql

package sqlc

import (
	"context"
)

const createStock = `-- name: CreateStock :one
INSERT INTO stock (product_id, quantity, min_quantity)
VALUES ($1, $2, $3)
RETURNING id, product_id, quantity, min_quantity
`

type CreateStockParams struct {
	ProductID   int32
	Quantity    int32
	MinQuantity int32
}

func (q *Queries) CreateStock(ctx context.Context, arg CreateStockParams) (Stock, error) {
	row := q.db.QueryRow(ctx, createStock, arg.ProductID, arg.Quantity, arg.MinQuantity)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.MinQuantity,
	)
	return i, err
}

const getStockByProductId = `-- name: GetStockByProductId :one
SELECT s.product_id,
       p.name                                                                   AS product_name,
       s.quantity,
       p.category,
       s.min_quantity,
       coalesce(count(m.id) FILTER (WHERE m.movement_type = 'LOSS'), 0)::int4   AS damaged_count,
       coalesce(count(m.id) FILTER (WHERE m.movement_type = 'RETURN'), 0)::int4 AS return_count
FROM stock s
         JOIN product p ON p.id = s.product_id
         LEFT JOIN stock_movement m ON m.product_id = p.id
WHERE s.product_id = $1
GROUP BY s.product_id, p.name, p.category, s.quantity, s.min_quantity
`

type GetStockByProductIdRow struct {
	ProductID    int32
	ProductName  string
	Quantity     int32
	Category     string
	MinQuantity  int32
	DamagedCount int32
	ReturnCount  int32
}

func (q *Queries) GetStockByProductId(ctx context.Context, productID int32) (GetStockByProductIdRow, error) {
	row := q.db.QueryRow(ctx, getStockByProductId, productID)
	var i GetStockByProductIdRow
	err := row.Scan(
		&i.ProductID,
		&i.ProductName,
		&i.Quantity,
		&i.Category,
		&i.MinQuantity,
		&i.DamagedCount,
		&i.ReturnCount,
	)
	return i, err
}

const listStock = `-- name: ListStock :many
SELECT s.product_id,
       p.name                                                                   AS product_name,
       p.category,
       s.quantity,
       s.min_quantity,
       coalesce(count(m.id) FILTER (WHERE m.movement_type = 'LOSS'), 0)::int4   AS damaged_count,
       coalesce(count(m.id) FILTER (WHERE m.movement_type = 'RETURN'), 0)::int4 AS return_count
FROM stock s
         JOIN product p ON p.id = s.product_id
         LEFT JOIN stock_movement m ON m.product_id = p.id
GROUP BY s.product_id, p.name, p.category, s.quantity, s.min_quantity
ORDER BY p.name
`

type ListStockRow struct {
	ProductID    int32
	ProductName  string
	Category     string
	Quantity     int32
	MinQuantity  int32
	DamagedCount int32
	ReturnCount  int32
}

func (q *Queries) ListStock(ctx context.Context) ([]ListStockRow, error) {
	rows, err := q.db.Query(ctx, listStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStockRow
	for rows.Next() {
		var i ListStockRow
		if err := rows.Scan(
			&i.ProductID,
			&i.ProductName,
			&i.Category,
			&i.Quantity,
			&i.MinQuantity,
			&i.DamagedCount,
			&i.ReturnCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStockByProductId = `-- name: UpdateStockByProductId :one
UPDATE stock
SET min_quantity = $1
WHERE product_id = $2
RETURNING id, product_id, quantity, min_quantity
`

type UpdateStockByProductIdParams struct {
	MinQuantity int32
	ProductID   int32
}

func (q *Queries) UpdateStockByProductId(ctx context.Context, arg UpdateStockByProductIdParams) (Stock, error) {
	row := q.db.QueryRow(ctx, updateStockByProductId, arg.MinQuantity, arg.ProductID)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Quantity,
		&i.MinQuantity,
	)
	return i, err
}
